// Day 11

I added an error message in all of the methods. I tested all the priority queue methods and functions and fixed the name of a variable in Heapify. I also copied the java code for the sparse matrix that I would like to translate to C. I moved the definition of two macros for infinity and nil to the header file of the Heap class. I noticed that newHeap() could take an argument for the maximum length of heap and take any size array by checking the size of the array internally. 

// Day 10

I did more thorough testing of the heap class. I added different tests for the different cases that can pop up when using the heap. I decided that the best implementation of the weight function is by changing the implementation of the Graph ADT to be based on sparse matrices for the adj list and the weights. Technically one could say it's already a sparse matrix but I am thinking of using the class from PA2 because it will allow for a third value, everything else is implicitly negative infinity or whatever it should be. I should be drawing and sketching things on a notepad more.


// Day 9

I deviced some tests for the priority queue methods and fixed one bug whereby when inserting a new entry, it'd be bubbled up past index 0 which is supposed to always be empty. I then copied List and Graph files to the directory of this project. I also decided that the single shortest path methods initialize() and relax() belong in Graph because of the access restrictions. I migrated those to Graph and adapted the names and such. This seems to be the last piece needed to finish this part of the project. The most important piece being resolving how I am going to go about implementing the weight function for the edges.

// Day 8

I decided to implement the priority queue by not renaming anything because I don't feel like it. The other thing I decided was that I would implement everything using an array that has a queue instead of an array that has an object with satellite data and a key. I then wrote the priorityQueue methods and adapted the ones I had already written to the Heap I had written. I was able to fix small syntax errors to get this to compile and I stopped there. 


// Day 7

Extra work today. I'd say I put in about 1 and a half hours.
I finally found the bug that was messing with heapSort(). I wasn't returning the right reference. I was assuming that the array pointer that I got for the array was okay to return. I didn't realize that it was it. In hindsight it should've been obvious. I also was doing a min heap when I needed a min heap to put the array in increasing order.
I was listening to a podcast and watching comedy shows while working on this. I realized that you have to do convince yourself of stuff much like sudoku by drawing the function of your algorithm and running through it instruction by instruction. You need more concentration than what multitasking allows me. Debugging by drawing is great.

// Day 6

Added a bunch of test comments in the program and decided that there's no need for preconditions for parent(), left(), and right() since they're internal and they could be private if this weren't C. I found an error in heapSort() probably. I left two entries in the TODO priorityQueue. 


// Day 5

I changed the way I defined buildHeap() and heapify(). Now, buildHeap() is a helper for newHeap. HeapSort() is it's own function that creates an inner heap. I decided that I would test every function with print statements. I looked at the length and now everything seems to be working. 

// Day 4

I fixed the runtime problems. The problem turned out to be that I never put the array in the heap so I was deleting memory that was part of the stack? Maybe just the first element in the array? No idea. I got rid of that in the contructor and later decided to copy the input array in the heap. I may need to just let the client deal with that memory, that's an option. I might need to read the literature on what is a heap supposed to do. I don't need to reinvent the wheel but I like the idea of thinking about it for my own future implementation.

I tested parent(), right(), left(), heapify() (Found out it runs, not thoroughly tested), and buildHeap() (the same as heapify, not a thorough test).

// Day 3

I finally got rid of all the compile time errors and had to commment out a few functions because I have to find a way to link the Heap.c and Heap.h to Graph.h and its respective implementation file. Now, what's left is to deal with the runtime errors that inevitably seemed to have cropped up.

// Day 2

I added left, right, and parent access functions. I got rid of some errors with naming. I decided that the array in the heap will be internal to the data structure and that I will later take what I have here to create a priorityQueue ADT. I am fixing compile time errors so that I can see if things compile and do further testing of what is doing what here.

// Day 1

I created the constructors using some relevant code examples that I got from Tantalo.
I added names for the functions.

I created the pointers and obj that implement the classes.

